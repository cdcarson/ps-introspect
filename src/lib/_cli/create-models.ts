import { SimplifiedDatabaseType } from '../api/enums.js.js';
import type { Connection } from '@planetscale/database';
import type {
  FriedaVars,
  Model,
  ParsedColumnDef,
  ParsedModelDef,
  RawTableColumnInfo,
  RawTableInfo,
  RepoDefinition,
  TableSearchIndexDefinition
} from './types.js';
import _ from 'lodash';
import { getSchema } from './db.js';
import { spinner } from '@clack/prompts';
import colors from 'picocolors';
import prettier from 'prettier';
import { join } from 'path';
import fs from 'fs-extra';
type RepoInfo = {
  modelName: string;
  classRepoName: string;
  classGetter: string;
  repoDef: { name: string; def: RepoDefinition<Model> };
  primary: { typeName: string; typeDef: string };
  create: { typeName: string; typeDef: string };
  update: { typeName: string; typeDef: string };
  unique: { typeName: string; typeDef: string };
  repo: { typeName: string; typeDef: string };
};

export const createModels = async (
  friedaVars: FriedaVars,
  connection: Connection
) => {
  const schemaSpinner = spinner();
  schemaSpinner.start('Fetching schema...');
  const schema = await getSchema(connection);
  schemaSpinner.start('Parsing schema...')
  const result = schema.map((t) => createModel(t));
  const modelsDirFullPath = join(
    process.cwd(),
    friedaVars.generatedModelsDirectory
  );
  const genFilePaths = {
    modelsShared: join(modelsDirFullPath, 'models.shared.ts'),
    castingServer: join(modelsDirFullPath, 'casting.server.ts'),
    reposServer: join(modelsDirFullPath, 'repos.server.ts')
  }
  const prettierOptions: prettier.Options = { singleQuote: true, trailingComma: 'none' };
  
  const bannerComment = `
    /**
      * This file is automatically generated from the database schema.
      * To regenerate, run \`frieda\`
      */   
     
    
     `;

  const castingServerTs = prettier.format(
    bannerComment + getSchemaCastsServerTs(result),
    {
      ...prettierOptions,
      filepath: genFilePaths.castingServer
    }
  );
  const modelsSharedTs = prettier.format(
    bannerComment + getModelsSharedTs(result),
    {
      ...prettierOptions,
      filepath: genFilePaths.modelsShared
    }
  );

  const reposServerTs = prettier.format(
    bannerComment + getReposServerTs(result),
    {
      ...prettierOptions,
      filepath: genFilePaths.reposServer
    }
  );

  
  schemaSpinner.stop(
    `Schema parsed. ${colors.gray(`[${schema.length} table(s)]`)}`
  );

  const writeSpinner = spinner();
  writeSpinner.start('Writing files...');
  await fs.ensureDir(modelsDirFullPath);
  await fs.writeFile(genFilePaths.castingServer, castingServerTs);
  await fs.writeFile(genFilePaths.modelsShared, modelsSharedTs);
  await fs.writeFile(genFilePaths.reposServer, reposServerTs);
  writeSpinner.stop('Done writing files.');


};

const createModel = (table: RawTableInfo): ParsedModelDef => {
  const columns = table.columns.map((c) => getColumnDef(c, table.name));
  return {
    name: table.name,
    columns,
    fullTextSearchIndexes: getTableFullTextSearchIndexes(table)
  };
};

const getJavascriptType = (
  column: RawTableColumnInfo,
  simpleType: SimplifiedDatabaseType,
  tableName: string
) => {
  if (simpleType === SimplifiedDatabaseType.Enum) {
    const result = column.Type.match(/enum\s*\(\s*([^)]+)\s*\)/i);
    if (!result) {
      throw new Error(
        `Unsupported enum type ${column.Type} for ${tableName}.${column.Field}`
      );
    }
    return result[1].split(',').join('|');
  }
  if (simpleType === SimplifiedDatabaseType.Json) {
    const result = column.Comment.match(/@jsontype\s*\(\s*([^)]+)\s*\)/i);
    return result ? result[1] : 'unknown';
  }
  switch (simpleType) {
    case SimplifiedDatabaseType.BigInt:
      return 'bigint';
    case SimplifiedDatabaseType.Int:
    case SimplifiedDatabaseType.Float:
      return 'number';
    case SimplifiedDatabaseType.Boolean:
      return 'boolean';
    case SimplifiedDatabaseType.Date:
      return 'Date';
    case SimplifiedDatabaseType.Key:
    case SimplifiedDatabaseType.String:
      return 'string';
    default:
      throw Error(
        `Could not calculate the javascript type for ${tableName}.${column.Field}`
      );
  }
};

const getSimplifiedDatabaseType = (
  column: RawTableColumnInfo,
  tableName: string
): SimplifiedDatabaseType => {
  // Deal with  bigint first. Assumed to be Key, unless the @bigint flag is in the comment
  if (/bigint/i.test(column.Type)) {
    return /@bigint/i.test(column.Comment)
      ? SimplifiedDatabaseType.BigInt
      : SimplifiedDatabaseType.Key;
  }
  // Deal with the other int types. Assumed to be Int, unless either @bigint or @boolean flags are present
  if (/int/i.test(column.Type)) {
    if (/@bigint/i.test(column.Comment)) {
      return SimplifiedDatabaseType.BigInt;
    }
    return /@boolean/i.test(column.Comment)
      ? SimplifiedDatabaseType.Boolean
      : SimplifiedDatabaseType.Int;
  }

  // floats...
  if (/float|double|decimal/i.test(column.Type)) {
    return SimplifiedDatabaseType.Float;
  }

  // enum...
  if (/enum/i.test(column.Type)) {
    return SimplifiedDatabaseType.Enum;
  }

  // datetime...
  if (/datetime/i.test(column.Type)) {
    return SimplifiedDatabaseType.Date;
  }

  // datetime...
  if (/json/i.test(column.Type)) {
    return SimplifiedDatabaseType.Json;
  }

  // all the string types...
  if (/text|char/i.test(column.Type)) {
    return SimplifiedDatabaseType.String;
  }

  // Out of luck for now. If we need to support other database types, add them later.
  throw new Error(
    `Unsupported database type ${column.Type} for ${tableName}.${column.Field}`
  );
};

const getColumnDef = (
  column: RawTableColumnInfo,
  tableName: string
): ParsedColumnDef => {
  const databaseType = getSimplifiedDatabaseType(column, tableName);
  const def: ParsedColumnDef = {
    name: column.Field,
    databaseType,
    javascriptType: getJavascriptType(column, databaseType, tableName),
    hasDefault: column.Default !== null,
    isPrimaryKey: /PRI/i.test(column.Key),
    nullable: /yes/i.test(column.Null),
    isCreatedAt: false,
    isUpdatedAt: false,
    maxStringLength: null,
    isPrimaryKeyGenerated: false,
    isDefaultGenerated: /DEFAULT_GENERATED/i.test(column.Extra),
    isGeneratedAlways:
      /STORED/i.test(column.Extra) && /GENERATED/i.test(column.Extra),
    isUnique: /UNI/i.test(column.Key)
  };
  if (def.isPrimaryKey && /auto_increment/i.test(column.Extra)) {
    def.isPrimaryKeyGenerated = true;
    def.isDefaultGenerated = true;
  }
  if (databaseType === SimplifiedDatabaseType.Date) {
    if (/DEFAULT_GENERATED/i.test(column.Extra)) {
      if (/on\s+update\s+CURRENT_TIMESTAMP/i.test(column.Extra)) {
        def.isUpdatedAt = true;
      } else {
        def.isCreatedAt = true;
      }
    }
  }
  if (databaseType === SimplifiedDatabaseType.String) {
    const result = column.Type.match(/\(\s*([\d]+)\s*\)/);
    if (result) {
      def.maxStringLength = parseInt(result[1]);
    }
  }
  return def;
};

const getTableFullTextSearchIndexes = (
  table: RawTableInfo
): TableSearchIndexDefinition[] => {
  const indexes: TableSearchIndexDefinition[] = [];
  table.indexes.forEach((rawIndex) => {
    if (!/FULLTEXT/i.test(rawIndex.Index_type)) {
      return;
    }
    const key = rawIndex.Key_name;
    let indexDef: TableSearchIndexDefinition | undefined = indexes.find(
      (i) => i.key === key
    );
    if (indexDef) {
      indexDef.indexedFields.push(rawIndex.Column_name);
    } else {
      indexDef = {
        key,
        indexedFields: [rawIndex.Column_name],
        tableName: table.name
      };
      indexes.push(indexDef);
    }
  });
  return indexes;
};

const getSchemaCastsServerTs = (modelDefs: ParsedModelDef[]): string => {
  const defs = modelDefs.flatMap((m) => {
    return m.columns.map(
      (c) => `'${m.name}.${c.name}': SimplifiedDatabaseType.${c.databaseType}`
    );
  });
  return `
    import { SimplifiedDatabaseType } from '$lib/database/types.server.js';

    export const schemaCasts = {
      ${defs.join(',\n')}
    }`;
};

const getModelsSharedTs = (modelDefs: ParsedModelDef[]): string => {
  const defs = modelDefs.map((m) => {
    const cols = m.columns.map((c) => {
      return `${c.name}: ${c.javascriptType}${c.nullable ? '|null' : ''};`;
    });
    return ` export type ${m.name} = {
      ${cols.join('\n')}
    }`;
  });
  return `
  import type { ArticlePricingTier } from '$lib/article-pricing.shared';
  import type { ImageSources } from '$lib/uploads/uploads.shared';
  import type Stripe from 'stripe';

  ${defs.join(`\n\n`)}
  `;
};

const getReposServerTs = (modelDefs: ParsedModelDef[]): string => {
  const infos: RepoInfo[] = modelDefs.map((m) => {
    const modelName = m.name;
    const classRepoName = `${_.camelCase(modelName)}`;
    const repoDefName = `${classRepoName}RepoDefinition`;
    const primaryKeyTypeName = `${m.name}PrimaryKey`;
    const createDataTypeName = `${m.name}CreateData`;
    const updateDataTypeName = `${m.name}UpdateData`;
    const findUniqueParamsTypeName = `${m.name}FindUniqueParams`;
    const repoTypeName = `${m.name}Repo`;
    const repoTypeDef = `Repo<${modelName}, ${primaryKeyTypeName}, ${createDataTypeName}, ${updateDataTypeName}, ${findUniqueParamsTypeName}>`;
    const repoDef: RepoDefinition<Model> = {
      name: m.name,
      columnKeys: m.columns.map((c) => c.name),
      primaryKeys: m.columns.filter((c) => c.isPrimaryKey).map((c) => c.name),
      autoIncrementingPrimaryKey:
        m.columns.find((c) => c.isPrimaryKey && c.isPrimaryKeyGenerated)
          ?.name || null,
      createdAtKeys: m.columns.filter((c) => c.isCreatedAt).map((c) => c.name),
      updatedAtKeys: m.columns.filter((c) => c.isUpdatedAt).map((c) => c.name),
      jsonKeys: m.columns
        .filter((c) => c.databaseType === SimplifiedDatabaseType.Json)
        .map((c) => c.name)
    };

    const classGetter = `get ${classRepoName}():${repoTypeName} {
      if (! this.repos.${classRepoName}) {
        this.repos.${classRepoName} = new Repo(${repoDefName}, this.connection)
      }
      return this.repos.${classRepoName};
    }`;
    const primaryKeyTypeDef = `
      {
        ${m.columns
          .filter((c) => c.isPrimaryKey)
          .map((c) => {
            return `${c.name}: ${c.javascriptType};`;
          })
          .join('\n')}
      }
    `;
    const createTypeDef = `
      {
        ${m.columns
          .filter((c) => {
            return !c.isGeneratedAlways;
          })
          .map((c) => {
            const optional = c.isDefaultGenerated || c.nullable;
            return `${c.name}${optional ? '?' : ''}: ${c.javascriptType};`;
          })
          .join('\n')}
        
       
      }
    `;
    const updateTypeDef = `
      {
        ${m.columns
          .filter((c) => {
            return !c.isGeneratedAlways && !c.isPrimaryKey;
          })
          .map((c) => {
            return `${c.name}?: ${c.javascriptType};`;
          })
          .join('\n')}
        
       
      }
    `;
    const uniqueDefs = m.columns
      .filter((c) => c.isUnique)
      .map((c) => `{${c.name}: ${c.javascriptType}}`);
    uniqueDefs.unshift(primaryKeyTypeName);
    const findUniqueParamsTypeDef = uniqueDefs.join('|');

    return {
      modelName,
      classRepoName,
      classGetter,
      primary: { typeName: primaryKeyTypeName, typeDef: primaryKeyTypeDef },
      create: { typeName: createDataTypeName, typeDef: createTypeDef },
      update: { typeName: updateDataTypeName, typeDef: updateTypeDef },
      unique: {
        typeName: findUniqueParamsTypeName,
        typeDef: findUniqueParamsTypeDef
      },
      repoDef: { name: repoDefName, def: repoDef },
      repo: { typeName: repoTypeName, typeDef: repoTypeDef }
    };
  });
  const types = infos
    .map((info) => {
      return `
      /** 
       * ${info.modelName}  
       */
      export type ${info.primary.typeName} = ${info.primary.typeDef}
      export type ${info.create.typeName} = ${info.create.typeDef}
      export type ${info.update.typeName} = ${info.update.typeDef}
      export type ${info.unique.typeName} = ${info.unique.typeDef}
      export type ${info.repo.typeName} = ${info.repo.typeDef}
      export const ${info.repoDef.name}: RepoDefinition<${
        info.modelName
      }> = ${JSON.stringify(info.repoDef.def)}

    `;
    })
    .join('\n\n');

  const classDef = `
    export abstract class AbstractAppDb extends AbstractDb {
      private repos: Partial<{${infos
        .map((info) => `${info.classRepoName}: ${info.repo.typeName}`)
        .join('\n')}}> = {};

      ${infos.map((info) => info.classGetter).join('\n')}
    }
  `;

  return `
    import type { RepoDefinition } from '../types.server.js';
    import { AbstractDb } from '../classes/abstract-db.server.js';
    import { Repo } from '../classes/crud-repo.server.js';
    import type { ArticlePricingTier } from '$lib/article-pricing.shared.js';
    import type { ImageSources } from '$lib/uploads/uploads.shared.js';
    import type Stripe from 'stripe';
    import type {
      ${modelDefs.map((m) => m.name).join(',')}
    } from './models.shared.js'

    ${types}

    ${classDef}
  `;
};

export const getSearchIndexesServerTs = (
  modelDefs: ParsedModelDef[]
): string => {
  const indexes = modelDefs.flatMap((m) => m.fullTextSearchIndexes);
  const mappedIndexes: { [key: string]: TableSearchIndexDefinition } = {};
  indexes.forEach((index) => (mappedIndexes[index.key] = index));
  return `
    import type { TableSearchIndexDefinition } from  '../types.server.js'
    export const searchIndexes: {[key: string]: TableSearchIndexDefinition} = ${JSON.stringify(
      mappedIndexes
    )}
  `;
};
